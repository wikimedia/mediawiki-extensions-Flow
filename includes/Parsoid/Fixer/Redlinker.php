<?php

namespace Flow\Parsoid\Fixer;

use ArrayObject;
use Closure;
use DOMDocument;
use DOMElement;
use DOMNode;
use Flow\Model\PostRevision;
use Flow\Parsoid\Fixer;
use Flow\Parsoid\Utils;
use LinkBatch;
use Linker;
use Title;

/**
 * Parsoid ignores red links. With good reason: redlinks should only be
 * applied when rendering the content, not when it's created. This
 * class updates HTML content from Parsoid with anchors generated by
 * Linker::link.
 *
 * An optional first stage, collectLinks, allows batching together the
 * db lookup for red vs blue status.  It receives an html string and
 * finds all anchor's which contain Parsoid Title strings and loads
 * those Title's into a LinkBatch. Additionally the register method
 * applies collectLinks to a post and its children recursively.
 *
 * The second stage, apply, receives an html string. It find all
 * anchor's which contain Parsoid Title strings and replaces them with
 * Linker::link generated anchors.  Current attributes and anchor
 * content are passed into Linker::link.
 *
 * Usage:
 *
 *	$redlinker = new Redlinker( new LinkBatch );
 *
 *	// Collect links to batch from html content directly
 *	foreach ( $foos as $foo ) {
 *	    $redlinker->collectLinks( $foo->getContent() );
 *	}
 *
 *	// Alternatively, the register method will read the content of a
 *	// post and all its children recursively.
 *	$redlinker->registerPost( $topicPost ); @todo fix this
 *
 *	// Before outputting content
 *	$content = $redlinker->apply( $foo->getContent(), Title::newMainPage() );
 */
class Redlinker implements Fixer {
	/**
	 * @var LinkBatch
	 */
	protected $batch;

	/**
	 * @param LinkBatch $batch
	 */
	public function __construct( LinkBatch $batch ) {
		$this->batch = $batch;
		$this->processed = new ArrayObject;
	}

	/**
	 * @return string
	 */
	public function getXPath() {
		return '//a[@rel="mw:WikiLink"]';
	}


	public function isRecursive( PostRevision $post ) {
		return $post->isFormatted();
	}

	/**
	 * Collect referenced Title's from html content and add to LinkBatch
	 *
	 * @param DOMNode $node html to check for titles
	 */
	public function recursive( DOMNode $node ) {
		if ( !$node instanceof DOMElement ) {
			return;
		}

		$href = $node->getAttribute( 'href' );
		if ( $href === '' ) {
			return;
		}
		// @todo Get proper title in here.  doesn't matter currently due to
		// the html from parsoid using '../../' style of relative
		// that don't strictly require the title its relative from.
		$title = Utils::createRelativeTitle( $href, Title::newMainPage() );
		if ( $title !== null ) {
			$this->batch->addObj( $title );
		}
	}

	/**
	 * Execute pending batched title lookup.
	 */
	public function resolve() {
		if ( !$this->batch->isEmpty() ) {
			$this->batch->execute();
			$this->batch->setArray( array() );
		}
	}

	/**
	 * Parsoid ignores red links. With good reason: redlinks should only be
	 * applied when rendering the content, not when it's created.
	 *
	 * This method will parse a given content, fetch all of its links & let MW's
	 * Linker class build the link HTML (which will take redlinks into account.)
	 * It will then substitute original link HTML for the one Linker generated.
	 *
	 * This replaces both existing and non-existant anchors because the relative links
	 * output by parsoid are not usable when output within a subpage.
	 *
	 * @param DOMDocument $dom
	 * @param Title $title Title to resolve relative links against
	 */
	public function apply( DOMNode $node, Title $title ) {
		if ( !$node instanceof DOMElement ) {
			return;
		}

		$href = $node->getAttribute( 'href' );
		if ( $href === '' ) {
			return;
		}

		$title = Utils::createRelativeTitle( $href, $title );
		if ( $title === null ) {
			return;
		}

		// finish any batch loading
		$this->resolve();

		// gather existing link attributes
		$attributes = array();
		foreach ( $node->attributes as $attribute ) {
			$attributes[$attribute->name] = $attribute->value;
		}
		// let MW build link HTML based on Parsoid data
		$html = Linker::link( $title, Utils::getInnerHtml( $node ), $attributes );
		// create new DOM from this MW-built link
		$replacementNode = Utils::createDOM( '<?xml encoding="utf-8"?>' . $html )
			->getElementsByTagName( 'a' )
			->item( 0 );
		// import MW-built link node into content DOM
		$replacementNode = $node->ownerDocument->importNode( $replacementNode, true );
		// replace Parsoid link with MW-built link
		$node->parentNode->replaceChild( $replacementNode, $node );
	}
}

