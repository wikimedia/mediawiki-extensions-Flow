<?php

namespace Flow\Parsoid\Fixer;

use ArrayObject;
use DOMElement;
use DOMNode;
use Flow\Model\PostRevision;
use Flow\Parsoid\Fixer;
use Flow\Parsoid\Utils;
use LinkBatch;
use Linker;
use Title;

/**
 * Parsoid ignores red links. With good reason: redlinks should only be
 * applied when rendering the content, not when it's created. This
 * class updates HTML content from Parsoid with anchors generated by
 * Linker::link.
 */
class Redlinker implements Fixer {
	/**
	 * @var LinkBatch
	 */
	protected $batch;

	/**
	 * @var ArrayObject
	 */
	protected $processed;

	/**
	 * @param LinkBatch $batch
	 */
	public function __construct( LinkBatch $batch ) {
		$this->batch = $batch;
		$this->processed = new ArrayObject;
	}

	/**
	 * @return string
	 */
	public function getXPath() {
		return '//a[@rel="mw:WikiLink"]';
	}

	/**
	 * @param PostRevision $post
	 * @return bool
	 */
	public function isRecursive( PostRevision $post ) {
		return $post->isFormatted();
	}

	/**
	 * Collect referenced Title's from html content and add to LinkBatch
	 *
	 * @param DOMNode $node html to check for titles
	 */
	public function recursive( DOMNode $node ) {
		if ( !$node instanceof DOMElement ) {
			return;
		}

		$href = $node->getAttribute( 'href' );
		if ( $href === '' ) {
			return;
		}
		// @todo Get proper title in here.  doesn't matter currently due to
		// the html from parsoid using '../../' style of relative
		// that don't strictly require the title its relative from.
		$title = Utils::createRelativeTitle( urldecode( $href ), Title::newMainPage() );
		if ( $title !== null ) {
			$this->batch->addObj( $title );
		}
	}

	/**
	 * Execute pending batched title lookup.
	 */
	public function resolve() {
		if ( !$this->batch->isEmpty() ) {
			$this->batch->execute();
			$this->batch->setArray( array() );
		}
	}

	/**
	 * Parsoid ignores red links. With good reason: redlinks should only be
	 * applied when rendering the content, not when it's created.
	 *
	 * This method will parse a given content, fetch all of its links & let MW's
	 * Linker class build the link HTML (which will take redlinks into account.)
	 * It will then substitute original link HTML for the one Linker generated.
	 *
	 * This replaces both existing and non-existent anchors because the relative links
	 * output by parsoid are not usable when output within a subpage.
	 *
	 * @param DOMNode $node
	 * @param Title $title Title to resolve relative links against
	 * @throws \Flow\Exception\WikitextException
	 */
	public function apply( DOMNode $node, Title $title ) {
		if ( !$node instanceof DOMElement ) {
			return;
		}

		$href = $node->getAttribute( 'href' );
		if ( $href === '' ) {
			return;
		}

		$title = Utils::createRelativeTitle( urldecode( $href ), $title );
		if ( $title === null ) {
			return;
		}

		// finish any batch loading
		$this->resolve();

		// gather existing link attributes
		$attributes = array();
		foreach ( $node->attributes as $attribute ) {
			$attributes[$attribute->name] = $attribute->value;
		}
		// let MW build link HTML based on Parsoid data
		$html = Linker::link( $title, Utils::getInnerHtml( $node ), $attributes );
		// create new DOM from this MW-built link
		$replacementNode = Utils::createDOM( '<?xml encoding="utf-8"?>' . $html )
			->getElementsByTagName( 'a' )
			->item( 0 );
		// import MW-built link node into content DOM
		$replacementNode = $node->ownerDocument->importNode( $replacementNode, true );
		// replace Parsoid link with MW-built link
		$node->parentNode->replaceChild( $replacementNode, $node );
	}
}
