{
  "comments": [
    {
      "key": {
        "uuid": "0ed113e2_c33f70d2",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 205,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-22T21:54:39Z",
      "side": 1,
      "message": "We should look at ways to integrate this with ve.init.mw.TargetLoader for the VE case.",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_8329689c",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 233,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-22T21:54:39Z",
      "side": 1,
      "message": "Can we do this in parallel with loading the new editor, rather than in series?",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_ebb27f91",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 233,
      "author": {
        "id": 214
      },
      "writtenOn": "2015-04-24T14:21:52Z",
      "side": 1,
      "message": "Unfortunately, we first need to load it to figure out which content format it wants the content in, so not without another refactor.",
      "parentUuid": "0ed113e2_8329689c",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_a326ecc7",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 243,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-22T21:54:39Z",
      "side": 1,
      "message": "This too could happen in parallel as soon as we know the editor switch is actually going to happen.",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_28967450",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 266,
      "author": {
        "id": 776
      },
      "writtenOn": "2015-04-20T16:56:14Z",
      "side": 1,
      "message": "i might just be mis-understanding how jquery promises work, but doesn\u0027t this resolve immediately in the above if/else if/else block, rather than when the chain of promises is complete?  If so i think it should only be resolving when the switch is finished.",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_63581d36",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 266,
      "author": {
        "id": 214
      },
      "writtenOn": "2015-04-20T17:35:58Z",
      "side": 1,
      "message": "You\u0027re right, but that\u0027s ok. Callbacks are always executed in order, so whatever you attach will only be executed after all of this code has run.",
      "parentUuid": "0ed113e2_28967450",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_8362c804",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 266,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-22T21:54:39Z",
      "side": 1,
      "message": "Please don\u0027t rely on jQuery\u0027s implementation detail of executing promise callbacks in order. It leads to confusing and fragile code that\u0027s easy to break.\n\nInstead, you should write this function like:\n\n    return mw.loader.using( stuff )\n        .then( function () {\n            ...\n            return something;\n        } )\n        .then( function ( data ) {\n            return blah;\n        } )\n        .....\n        .then( function () {\n            return finalResult;\n         } );\n\nand that\u0027ll return a promise that is resolved with finalResult only after all the steps are complete. This explicitly guarantees the execution order.\n\nIf you need to reject the promise from a success handler, you can do that by returning a new rejected promise:\n\n    // we succeeded so far\n    .then( function () {\n        if ( some condition ) {\n            return $.Deferred().reject( some data );\n        }\n    } )\n    // now we\u0027re failing\n\nIf you need to act on failures or remap failure data, you can do that by passing the second parameter to then:\n\n    .then( null, function ( failureData ) {\n        log( failureData );\n        return newFailureData;\n     } );",
      "parentUuid": "0ed113e2_63581d36",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_cb78dbc1",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 266,
      "author": {
        "id": 214
      },
      "writtenOn": "2015-04-24T14:21:52Z",
      "side": 1,
      "message": "I\u0027m probably not seeing something here.\n\nHow is:\n\n    return mw.loader.using( stuff )\n        .then( function () {\n            ...\n            return something;\n        } )\n        .then( function ( data ) {\n            return blah;\n        } )\n        .....\n        .then( function () {\n            return finalResult;\n         } );\n\ndifferent from:\n\n    deferred\n        .then( function () {\n            return mw.loader.using( stuff );\n        } )\n        .then( function () {\n            ...\n            return something;\n        } )\n        .then( function ( data ) {\n            return blah;\n        } )\n        .....\n        .then( function () {\n            return finalResult;\n         } );\n\n    return deferred.promise();\n\nBoth of them just return a promise object with some .then handlers attached to them. I don\u0027t see how either of them guarantees execution other while the other doesn\u0027t - both of them are the same thing.\n\nOr am I missing some other point?",
      "parentUuid": "0ed113e2_8362c804",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_368695bf",
        "filename": "modules/editor/ext.flow.editor.js",
        "patchSetId": 3
      },
      "lineNbr": 266,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-28T20:48:17Z",
      "side": 1,
      "message": ".then() doesn\u0027t just attach a handler, it also returns a new promise that wraps the old one.\n\nConsider:\n\n    dfdA \u003d $.Deferred();\n    promiseA \u003d dfdA.promise();\n    promiseB \u003d promiseA.then( function () {\n        console.log(\u0027then\u0027);\n        return $.ajax( .... );\n    } );\n    promiseA.done( function()  { console.log(\u0027A done\u0027); } );\n    promiseB.done( function () { console.log(\u0027B done\u0027); } );\n    dfdA.resolve();\n\nThe output of this will be:\n\n    then\n    A done\n    [a few seconds pass]\n    B done\n\nBecause what the .then call does is it waits for promiseA to resolve, then runs the callback, and because that returns another promise (the AJAX request), it first waits for that promise to resolve before resolving promiseB. However, in the meantime, the promiseA.done callback can execute. It does execute after the .then callback because it was registered later, but it doesn\u0027t wait for the AJAX request.\n\nIn your case, the promise you return is resolved immediately, whereas the .then() chain contains async operations (mw.loader.using is sometimes async, mw.flow.parsoid.convert is always async). So the promise returned by this function will resolve before pretty much anything has happened.\n\nI think it would be helpful to have the promise resolve with the *instance* of the loaded editor, rather than its name. The instance won\u0027t be available until the editor has fully finished loading, so that will force us to do it right.",
      "parentUuid": "0ed113e2_cb78dbc1",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ed113e2_031d7878",
        "filename": "modules/editor/ext.flow.parsoid.js",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-04-22T21:54:39Z",
      "side": 1,
      "message": "You shouldn\u0027t need to put this here. Instead, remap the rejection data in switchEditor",
      "revId": "0729addd49ae4c21b2a6979ce9ecad41250480b8",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    }
  ]
}