/*!
 * Implements a Handlebars layer for FlowBoard.TemplateEngine
 */

( function ( $, Handlebars ) {
	window.mw = window.mw || {}; // mw-less testing
	mw.flow = mw.flow || {}; // create mw.flow globally

	var _timestamp = {
			list: [],
			currentIndex: 0
		},
		_tplcache = {};

	/**
	 * Instantiates a FlowHandlebars instance for TemplateEngine.
	 * @param {Object} FlowStorageEngine
	 * @returns {FlowHandlebars}
	 * @constructor
	 */
	function FlowHandlebars( FlowStorageEngine ) {
		return this;
	}

	mw.flow.FlowHandlebars = FlowHandlebars;

	/**
	 * Returns a given template function. If template is missing, the template function is noop with mw.flow.debug.
	 * @param {String} templateName
	 * @returns {Function}
	 */
	FlowHandlebars.prototype.getTemplate = function ( templateName ) {
		if ( _tplcache[templateName] ) {
			// Return cached compiled template
			return _tplcache[templateName];
		}

		// Find other templates in the page and compile them
		$( 'script[type="text/x-handlebars-template"]' ).each( function () {
			var $this = $( this ),
				id = $this.attr( 'id' ).replace( '-partial', '');

			FlowHandlebars.prototype.registerTemplate( id, $this.html() );

			//$this.remove();
		} );

		return _tplcache[ templateName ] || function () { mw.flow.debug( '[Handlebars] Missing template', arguments ); };
	};

	/**
	 * Processes a given template and returns the actual DOM nodes generated by it.
	 * @param {String} templateName
	 * @param {*} [args]
	 * @returns {Element[]|Element}
	 */
	FlowHandlebars.prototype.processTemplate = function ( templateName, args ) {
		return FlowHandlebars.prototype.getTemplate( templateName )( args );
	};

	FlowHandlebars.prototype.registerTemplate = function ( templateName, html ) {
		// Compile this template once.
		_tplcache[ templateName ] = Handlebars.compile( html );

		// Overwrite Handlebars' partials with our template cache instead. Much easier.
		Handlebars.partials = _tplcache;
		//Handlebars.registerPartial( name, html );

		return _tplcache[ templateName ];
	};

	// @todo remove and replace with mw.message || $.noop
	mw.message = mw.message || function ( str ) {
		var strings = ( {
				"No_header": "This talk page has no header.",
				"Reply": "Reply",
				"Edit": "Edit",
				"Newest_topics": "Newest topics",
				"Small_topics": "Small topics",
				"Topics_only": "Topics only",
				"Topics_and_posts": "Topics and posts",
				"Topics": "Topics",
				"Topics_n": function ( count, options ) {
					return "Topics (" + count + ")";
				},
				"Load_More": "Load More",
				"Start_a_new_topic": "Start a new topic",
				"topic_details_placeholder": "Add some details, if you'd like.",
				"Cancel": "Cancel",
				"Preview": "Preview",
				"Add_Topic": "Add Topic",
				"Talk": "Talk",
				"block": "block",
				"Lock": "Lock",
				"Hide": "Hide",
				"Delete": "Delete",
				"Suppress": "Suppress",

				"started_with_participants": function ( context, options ) {
					var author = context.author;
					return author.name + " started this topic" +
						( context.author_count > 1 ? (
						", with " + ( context.author_count - 1 ) + " other participant" +
							( context.author_count > 2 ? 's' : '' )
						) : '' );
				},
				"topic_count_sidebar": function ( context, options ) {
					return "Showing " + context.roots.length + " of " + context.topic_count + " topics attached to this page";
				},
				"Reply_to_author_name": function ( context, options ) {
					return "Reply to " + context.author.name;
				},
				"comment_count": function ( context, options ) {
					return context.reply_count + " comment" + ( !context.reply_count || context.reply_count > 1 ? 's' : '' );
				},

				"topic_TOU": FlowHandlebars.prototype.html( 'By clicking add topic, you agree to our <a rel="nofollow" class="external text" href="//wikimediafoundation.org/wiki/Terms_of_use">Terms of Use</a> and agree to irrevocably release your text under the <a rel="nofollow" class="external text" href="//creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0 License</a> and <a rel="nofollow" class="external text" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License">GFDL</a>.' ),
				"reply_TOU": FlowHandlebars.prototype.html( 'By clicking reply, you agree to our <a rel="nofollow" class="external text" href="//wikimediafoundation.org/wiki/Terms_of_use">Terms of Use</a> and agree to irrevocably release your text under the <a rel="nofollow" class="external text" href="//creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0 License</a> and <a rel="nofollow" class="external text" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License">GFDL</a>.' ),

				"_time": function ( seconds_ago ) {
					var str = ' second',
						new_time = seconds_ago;

					if ( seconds_ago >= 604800 ) {
						new_time = seconds_ago / 604800;
						str = ' week';
					} else if ( seconds_ago >= 86400 ) {
						new_time = seconds_ago / 86400;
						str = ' day';
					} else if ( seconds_ago >= 3600 ) {
						new_time = seconds_ago / 3600;
						str = ' hour';
					} else if ( seconds_ago >= 60 ) {
						new_time = seconds_ago / 60;
						str = ' minute';
					}

					return Math.floor( new_time ) + str + ( new_time < 1 || new_time >= 2 ? 's' : '' );
				},
				"time_ago": function ( seconds_ago ) { return this._time( seconds_ago ) + " ago"; },
				"active_ago": function ( seconds_ago ) { return "Active " + this.time_ago( seconds_ago ); },
				"started_ago": function ( seconds_ago ) { return "Started " + this.time_ago( seconds_ago ); },
				"edited_ago": function ( seconds_ago ) { return "Edited " + this.time_ago( seconds_ago ); },

				"datetime": function ( timestamp ) {
					return ( new Date( timestamp ) ).toLocaleString();
				}
			} ),
			result = strings[ str ];

		if ( Object.prototype.toString.call( result ) === '[object Function]' ) {
			// Callable; return the result of callback(arguments)
			result = result.apply( strings, Array.prototype.slice.call( arguments, 1 ) );
		}

		// Return the result string
		return { text: function () { return result; } };
	};

	/**
	 * Calls mw.message to get localized message strings.
	 * @example {{l10n "reply_count" 12}}
	 * @param {String} str
	 * @param {...*} [args]
	 * @param {Object} [options]
	 * @returns {String}
	 */
	FlowHandlebars.prototype.l10n = function ( str, args, options ) {
		var res = mw.message.apply( mw, arguments ).text();

		if ( !res ) {
			mw.flow.debug( "[l10n] Empty String", arguments );
			return "(l10n:" + str + ")";
		}

		return res;
	};

	// Register l10n
	Handlebars.registerHelper( 'l10n', FlowHandlebars.prototype.l10n );

	/**
	 * @example {{uuidTimestamp uuid "started_ago"}}
	 * @param {String} uuid
	 * @param {String} str
	 * @param {bool} [timeAgoOnly]
	 * @returns {String|undefined}
	 */
	FlowHandlebars.prototype.uuidTimestamp = function( uuid, str, timeAgoOnly ) {
		var timestamp = parseInt( parseInt( uuid, 36 ).toString( 2 ).substr( 0, 41 ), 2 );
		return FlowHandlebars.prototype.timestamp( timestamp, str, timeAgoOnly );
	};

	// Register uuidTimestamp
	Handlebars.registerHelper( 'uuidTimestamp', FlowHandlebars.prototype.uuidTimestamp );

	/**
	 * Generates markup for an "nnn sssss ago" and date/time string.
	 * @example {{timestamp start_time "started_ago"}}
	 * @param {int} timestamp
	 * @param {String} str
	 * @param {bool} [timeAgoOnly]
	 * @returns {String|undefined}
	 */
	FlowHandlebars.prototype.timestamp = function ( timestamp, str, timeAgoOnly ) {
		if ( !timestamp || !str ) {
			mw.flow.debug( '[timestamp] Invalid arguments', arguments);
			return;
		}

		var time_ago,
			seconds_ago = ( +new Date() - timestamp ) / 1000;

		if ( seconds_ago < 2419200 ) {
			// Return "n ago" for only dates less than 4 weeks ago
			time_ago = FlowHandlebars.prototype.l10n( str, seconds_ago );

			if ( timeAgoOnly === true ) {
				// timeAgoOnly: return only this text
				return time_ago;
			}
		} else if ( timeAgoOnly === true ) {
			// timeAgoOnly: return nothing
			return;
		}

		// Store this in the timestamps auto-updater array
		_timestamp.list.push( { guid: null, timestamp: timestamp, str: str, failcount: 0 } );

		// Render the timestamp template
		return FlowHandlebars.prototype.html(
			FlowHandlebars.prototype.processTemplate(
				'timestamp',
				{
					time_iso: timestamp,
					time_readable: FlowHandlebars.prototype.l10n( 'datetime', timestamp ),
					time_ago: time_ago,
					guid: null
				}
			)
		);
	};

	// Register l10n
	Handlebars.registerHelper( 'timestamp', FlowHandlebars.prototype.timestamp );

	/**
	 * Updates one <time> node at a time every 100ms, until finishing, and then sleeps 5s.
	 * Nodes do not get updated again until they have changed.
	 * @todo Perhaps only update elements within the viewport?
	 * @todo Maybe updating elements every few seconds is distracting? Think about this.
	 */
	function timestampAutoUpdate() {
		var arrayItem, $ago, failed, secondsAgo, text,
			currentTime = +new Date() / 1000;

		// Only update elements that need updating (eg. only update minutes every 60s)
		do {
			arrayItem = _timestamp.list[ _timestamp.list._currentIndex ];

			if ( !arrayItem || !arrayItem.nextUpdate || currentTime >= arrayItem.nextUpdate ) {
				break;
			}

			// Find the next array item
			_timestamp.list._currentIndex++;
		} while ( arrayItem );

		if ( !arrayItem ) {
			// Finished array; reset loop
			_timestamp.list._currentIndex = 0;

			// Run again in 5s
			setTimeout( timestampAutoUpdate, 5000 );
			return;
		}

		$ago = $( '#' + arrayItem.guid );
		failed = true;
		secondsAgo = currentTime - ( arrayItem.timestamp / 1000 );

		if ( $ago && $ago.length ) {
			text = FlowHandlebars.prototype.timestamp( arrayItem.timestamp, arrayItem.str, true );

			// Returned a valid "n ago" string?
			if ( text ) {
				// Reset the failcount
				failed = arrayItem.failcount = 0;

				// Set the next update time
				arrayItem.nextUpdate = currentTime + ( secondsAgo > 604800 ? 604800 - currentTime % 604800 : ( secondsAgo > 86400 ? 86400 - currentTime % 86400 : ( secondsAgo > 3600 ? 3600 - currentTime % 3600 : ( secondsAgo > 60 ? 60 - currentTime % 60 : 1 ) ) ) );

				// Only touch the DOM if the text has actually changed
				if ( $ago.text() !== text ) {
					$ago.text( text );
				}
			}
		}

		if ( failed && ++arrayItem.failcount > 9 ) {
			// Remove this array item if we failed this 10 times in a row
			_timestamp.list.splice( _timestamp.list._currentIndex, 1 );
		} else {
			// Go to next item
			_timestamp.list._currentIndex++;
		}

		// Run every 100ms until we update all nodes
		setTimeout( timestampAutoUpdate, 100 );
	}

	$( document ).ready( timestampAutoUpdate );

	/**
	 * Do not escape HTML string. Used as a Handlebars helper.
	 * @example {{html "<div/>"}}
	 * @param {String} string
	 * @returns {String|Handlebars.SafeString}
	 */
	FlowHandlebars.prototype.html = function ( string ) {
		return new Handlebars.SafeString( string );
	};

	// Register html
	Handlebars.registerHelper( 'html', FlowHandlebars.prototype.html );

	/**
	 * Render a block instance. Used as a Handlebars helper.
	 * @example {#each blocks}}{{block this}}{{/each}}
	 * @param {Object} context
	 * @returns {String|Handlebars.SafeString}
	 */
	FlowHandlebars.prototype.block = function( block ) {
		var template = FlowHandlebars.prototype.getTemplate( "flow_block_" +block.type );
		return new Handlebars.SafeString(template(block));
	};

	// Register block
	Handlebars.registerHelper( 'block', FlowHandlebars.prototype.block );

	/**
	 * Accept a list of revisionIds and iterate their associated revision
	 * @example {#eachPost this roots #}...{{/eachPost}}
	 * @param {Object} topic or topiclist api result
	 * @param {Array} list of post id's to iterate
	 * @parma {Object} handlebars invocation options
	 * @return {String}
	 */
	FlowHandlebars.prototype.eachPost = function( context, postIds, options ) {
		var revId, data, i,
			fn = options.fn,
			ret = "";

		if ( postIds.length === 0 ) {
			options.inverse( this );
		} else {
			if ( options.data ) {
				data = Handlebars.createFrame( options.data );
			}

			for ( i = 0; i < postIds.length; i++ ) {
				if ( data ) {
					data.index = i;
					data.first = ( i === 0 );
					data.last = ( i === ( postIds.length - 1 ) );
				}
				// top revision available for specified postId
				// @todo more carefully
				revId = context.posts[postIds[i]][0];
				ret = ret + fn( context.revisions[revId], { data: data } );
			}
		}

		return ret;
	};

	// Register eachPost
	Handlebars.registerHelper( 'eachPost', FlowHandlebars.prototype.eachPost );

	/**
	 * Returns the author context using the current context's author_id key.
	 * @example {{#author this}}{{name}}{{/author}}
	 * @param {Object} context
	 * @param {Object} options
	 * @returns {String}
	 */
	FlowHandlebars.prototype.authorBlock = function ( context, options ) {
		var author = ''; //options.data.root.authors[ context.author_id ] || { name: 'error', gender: null, wiki: null };
		return options.fn ? options.fn( author ) : author;
	};

	// Register html
	Handlebars.registerHelper( 'author', FlowHandlebars.prototype.authorBlock );

	/**
	 * Gets a URL for a given variable.
	 * @example {{url "board.search"}}
	 * @param {String} str
	 * @param {Object} options
	 * @returns {String}
	 * @todo Implement
	 */
	FlowHandlebars.prototype.url = function ( str, options ) {
		return Array.prototype.pop.apply( arguments );
	};

	// Register html
	Handlebars.registerHelper( 'url', FlowHandlebars.prototype.url );

	/**
	 * Creates a form element based on the given input.
	 * Automatically applies mw-ui-button classes and creates sibling mw-ui nodes.
	 * Takes option keys:
	 * * String: content, role, pattern, name, value, placeholder
	 * * Bool: required, collapsible, expandable
	 * * Number: maxlength, min, max, step, rows, cols
	 * @example {{formElement this "button" class="mw-ui-sleeper" text='{{l10n "Preview"}}'}}
	 * @param {Object} context
	 * @param {String} type
	 * @param {Object} options
	 * @returns {String}
	 */
	FlowHandlebars.prototype.formElement = function ( context, type, options ) {
		var hash = options.hash,
			data = {
				tag:         type,
				fieldtype:   null,
				closing_tag: null,
				'class':     hash['class'] || '',
				required:    !!hash.required,
				maxlength:   hash.maxlength,
				pattern:     hash.pattern,
				name:        hash.name,
				value:       hash.value,
				content:     hash.content,
				role:        hash.role || type,
				collapsible: !!hash.collapsible,
				expandable:  !!hash.expandable,
				radio:       false,
				checkbox:    false
			};

		switch ( type ) {
			case 'submit':
			case 'reset':
			case 'button':
				data.tag = 'button';
				data.closing_tag = data.tag;

				// Apply mw-ui- class based on role (or type if role is omitted)
				switch ( hash.role || type ) {
					case 'submit':
					case 'constructive':
						data.fieldtype = 'constructive';
						break;

					case 'action':
					case 'progressive':
						data.fieldtype = 'progressive';
						break;

					case 'regressive':
						data.fieldtype = 'regressive';
						break;

					case 'cancel':
					case 'reset':
					case 'destructive':
						data.fieldtype = 'destructive';
						break;

					default:
						data.fieldtype = 'button';
						break;
				}

				if ( data.fieldtype !== 'button' ) {
					data['class'] = 'flow-ui-' + data.fieldtype + ' ' + data['class'];
				}
				data['class'] = 'flow-ui-button ' + data['class'];
				break;

			case 'color':
			case 'date':
			case 'email':
			case 'number':
			case 'url':
			case 'range':
			case 'time':
				data.validation = true;
			/* fall through */
			case 'search':
			case 'text':
			case 'input':
				data.tag = 'input';
				data.fieldtype = type === 'input' ? 'text' : type;
				data.validation = data.validation || data.required || data.min || data.max;
				data.type = type === 'input' ? 'text' : type;
				if ( type !== 'color' && type !== 'range' ) {
					// These are NOT styled correctly yet
					data['class'] = 'mw-ui-input ' + data['class'];
				}
				data.min = hash.min;
				data.max = hash.max;
				data.step = hash.step;
				break;

			case 'textarea':
				data.closing_tag = data.tag;
				data['class'] = 'mw-ui-input ' + data['class'];
				data.validation = true;
				data.rows = hash.rows;
				data.cols = hash.cols;
				break;

			case 'radio':
			case 'checkbox':
				data.tag = 'input';
				data.type = type;
				data.fieldtype = type;
				data.radio = type === 'radio';
				data.checkbox = type === 'checkbox';
				data.validation = true;
				if ( data.content ) {
					data.content = ' ' + data.content;
				}
				break;

			default:
				break;
		}

		if ( hash.placeholder ) {
			data.placeholder = Handlebars.compile( hash.placeholder )( context, options );
		}

		return FlowHandlebars.prototype.html( FlowHandlebars.prototype.processTemplate( 'form_element', data ) );
	};

	// Register html
	Handlebars.registerHelper( 'formElement', FlowHandlebars.prototype.formElement );

	/**
	 *
	 * @example {{generateUID}}
	 * @returns {String}
	 */
	FlowHandlebars.prototype.generateUID = function () {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g , function ( c ) {
			var r = Math.random() * 16 | 0, v = ( c === 'x' ? r : ( r & 0x3 | 0x8 ) );
			return v.toString( 16 );
		} );
	};

	// Register html
	Handlebars.registerHelper( 'generateUID', FlowHandlebars.prototype.generateUID );

	/**
	 * Simple math.
	 * @example {{math @index "+" 1}}
	 * @param {Number} lvalue
	 * @param {String} operator
	 * @param {Number} rvalue
	 * @param {Object} options
	 * @return {Number}
	 */
	FlowHandlebars.prototype.math = function ( lvalue, operator, rvalue, options ) {
		lvalue = parseFloat(lvalue);
		rvalue = parseFloat(rvalue);

		return {
			"+": lvalue + rvalue,
			"-": lvalue - rvalue,
			"*": lvalue * rvalue,
			"/": lvalue / rvalue,
			"%": lvalue % rvalue
		}[operator];
	};

	// Register math
	Handlebars.registerHelper( 'math', FlowHandlebars.prototype.math );
}( jQuery, Handlebars ) );
